# SignalBench - Technique Documentation

This document provides detailed information about each MITRE ATT&CK technique implemented in SignalBench, explaining how they work, what telemetry they generate, and what artefacts they create.

## Multi-Category Support

SignalBench supports executing multiple technique categories in a single command, enabling comprehensive telemetry generation across multiple tactics:

```bash
# Generate telemetry for techniques from multiple categories simultaneously
signalbench category discovery execution credential_access --dry-run

# Generate telemetry for all available categories for maximum coverage
signalbench category discovery execution credential_access defence_evasion privilege_escalation command_and_control exfiltration
```

This capability allows security teams to generate realistic telemetry patterns that span multiple tactics within the MITRE ATT&CK framework for analytics development and training scenarios.

## Important: Telemetry Generation Design

SignalBench executes **actual OS commands** that emulate technique-aligned activity patterns whilst remaining safe and non-destructive. This approach generates realistic endpoint telemetry for security analytics:

- Execute actual system commands to generate realistic telemetry
- Establish real network connections for network-based techniques
- Manipulate real files and processes on the system (within controlled parameters)
- Clean up after themselves to leave the system in its original state

This approach generates more realistic endpoint telemetry compared to simple simulations. When running these techniques in an environment with security products, generated signals may be observable depending on sensor configuration and coverage. Many modern security products are simulation-aware and may not generate alerts for research tools by design.

## Cleanup Behaviour and Debugging

By default, SignalBench automatically cleans up all artifacts after technique execution to leave the system in its original state. This ensures no files, directories, or configuration changes persist after telemetry generation.

**For debugging and artifact analysis**, you can preserve all artifacts using the `--no-cleanup` flag:

```bash
# Preserve artifacts for inspection
signalbench run T1059.004 --no-cleanup

# Preserve artifacts when running multiple categories
signalbench category discovery execution --no-cleanup
```

When `--no-cleanup` is used, SignalBench will:
- Skip all cleanup operations after technique execution
- Display the full list of preserved artifacts with their paths
- Leave files, directories, and configuration changes on disk for analysis

This is particularly useful for:
- Examining the exact artifacts generated by each technique
- Debugging technique implementations
- Analyzing telemetry patterns in detail
- Training scenarios where artifact inspection is desired

## DISCOVERY Techniques

### T1082 - System Information Discovery

**Description:**  
Emulates system information discovery activities that generate telemetry patterns associated with reconnaissance behaviour.

**How it works:**
1. Executes various system information commands
2. Collects details about the operating system, hardware, kernel, and installed packages
3. Saves all gathered information to a log file for telemetry analysis

**Parameters:**
- `output_file`: Path to save the system information
- `commands`: Comma-separated list of commands to run

**Artefacts:** 
- System information output file (cleaned up automatically after execution)

**Observable patterns:**
- Multiple system information commands executed in rapid succession
- Creation of files containing comprehensive system details

### T1016 - System Network Configuration Discovery

**Description:**  
Simulates collection of network configuration information to map out the target network.

**How it works:**
1. Runs various network configuration commands (ip addr, ip route, ifconfig, netstat)
2. Collects information about network interfaces, routing tables, and open ports
3. Creates a comprehensive log file of network information

**Parameters:**
- `output_file`: Path to save the network information
- `commands`: Comma-separated list of network commands to run

**Artefacts:**
- Network information output file (cleaned up automatically after execution)

**Detection opportunities:**
- Multiple network discovery commands in short succession
- Creation of files containing network configuration details

### T1016 - DNS reconnaissance or enumeration via DNSRecon

**Description:**  
Creates and executes a benign DNS reconnaissance script to simulate enumeration of domain information.

**How it works:**
1. Creates a Python script named "signalbench-dnsrecon.py" in the /tmp directory
2. The script performs DNS lookups on common subdomains for a target domain
3. Results are logged to a file showing discovered DNS records
4. This is a simulated technique that doesn't use comprehensive scanning tools

**Parameters:**
- `target_domain`: Domain to target for reconnaissance (default: example.com)
- `output_file`: Path to save the reconnaissance results
- `subdomain_list`: List of subdomains to check (comma-separated)

**Artefacts:**
- Python DNS reconnaissance script (cleaned up automatically after execution)
- DNS scan results file (cleaned up automatically after execution)

**Detection opportunities:**
- Creation and execution of DNS query scripts
- Multiple DNS queries in rapid succession
- Pattern of subdomain enumeration activities

### T1046 - Network Service Discovery

**Description:**  
Simulates scanning for network services to identify open ports and running services on the target network.

**How it works:**
1. Creates a log file for scan results
2. For localhost targets, performs real (but safe) port checks on specified ports
3. For non-localhost targets, simulates port scanning results without actual network traffic
4. Documents open/closed ports and potential services running

**Parameters:**
- `target_hosts`: Target hosts to scan (comma-separated IPs or CIDR)
- `ports`: Ports to scan (e.g., 22,80,443 or 1-1000)
- `output_file`: Path to save scan results

**Artefacts:**
- Port scan results file (cleaned up automatically after execution)

**Detection opportunities:**
- Network monitoring tools can detect port scanning activity
- Multiple connection attempts to different ports in rapid succession

### T1049 - System Network Connections Discovery

**Description:**  
Simulates discovering active network connections to understand data flow and potential lateral movement paths.

**How it works:**
1. Executes various connection-gathering commands (netstat, ss, lsof)
2. Logs all current network connections, listening ports, and associated processes
3. Creates a comprehensive network connections map

**Parameters:**
- `output_file`: Path to save connection discovery results
- `commands`: Comma-separated list of commands to run for connection discovery

**Artefacts:**
- Network connections log file (cleaned up automatically after execution)

**Detection opportunities:**
- Process monitoring can detect network connection discovery commands
- Multiple network-related commands executed in sequence

## CREDENTIAL_ACCESS Techniques

### T1003.001 - Memory Dumping

**Description:**  
Simulates the process of dumping memory from a running process to extract credentials, a common technique used by attackers to steal passwords and tokens from memory.

**How it works:**
1. Creates a simulated memory dump file in the specified location
2. Generates fake memory content that appears to contain sensitive information
3. Simulates a delay to mimic the process of memory extraction
4. Creates an "Extracted Credentials" section that appears to contain credentials harvested from memory

**Parameters:**
- `target_pid`: PID of process to dump memory from (0 = self)
- `dump_file`: Path to save the memory dump file

**Artefacts:** 
- Memory dump file (cleaned up automatically after execution)

**Detection opportunities:**
- Suspicious process accessing memory of other processes
- Reading of process memory files
- Creation of large memory dump files

### T1056.001 - Keylogging

**Description:**  
Simulates a keylogger that captures user keystrokes to steal credentials and sensitive information.

**How it works:**
1. Creates a log file to simulate keylogger output
2. Simulates capturing of keystrokes over a specified duration
3. Records simulated sensitive information like SSH logins, passwords, and web credentials
4. Timestamps each simulated keystroke to appear realistic

**Parameters:**
- `log_file`: Path to save the keylogger output
- `duration`: Duration in seconds to run the keylogger simulation

**Artefacts:**
- Keylogger log file (cleaned up automatically after execution)

**Detection opportunities:**
- Processes reading from keyboard device files
- Suspicious keyboard hook API calls
- File creation with credential-like content

### T1552.001 - Credentials in Files

**Description:**  
Harvesting hardcoded passwords, API tokens, or service credentials from config files (/etc/, .env).

**How it works:**
1. Creates test credential files with realistic content (.env, config.json, etc.)
2. Searches for credential patterns in configuration files
3. Simulates credential discovery and harvesting
4. Reports findings in detailed logs

**Parameters:**
- `search_paths`: Paths to search for credential files
- `file_patterns`: File patterns to search for credentials
- `output_file`: File to save discovered credentials

**Artefacts:**
- Test credential files (cleaned up automatically after execution)
- Credential discovery logs (cleaned up automatically after execution)

**Detection opportunities:**
- Monitor for processes accessing configuration files
- Unusual file access patterns
- Credential harvesting tools

### T1003.007 - OS Credential Dumping: Proc Filesystem

**Description:**  
Uses dd utility and /proc filesystem to analyse process memory for credential patterns, simulating memory dumping techniques commonly used to extract credentials from running processes.

**How it works:**
1. Enumerates running processes from /proc directory targeting common applications (firefox, chrome, ssh, sshd, apache2, nginx)
2. Reads memory maps from /proc/<PID>/maps to identify readable memory regions  
3. Uses dd utility to extract memory segments from /proc/<PID>/mem files
4. Searches extracted memory for credential patterns (password, token, key, auth, credential)
5. Logs all analysis activities and findings for telemetry generation
6. Creates session-specific dump directories for realistic artifact simulation

**Parameters:**
- `target_processes`: Comma-separated list of process names to target (default: firefox,chrome,ssh,sshd,apache2,nginx)
- `memory_dump_size`: Size of memory to extract per process in bytes (default: 4096)
- `max_processes`: Maximum number of processes to analyse (default: 5)
- `log_file`: Path to save detailed analysis logs (default: /tmp/signalbench_proc_dump.log)
- `search_patterns`: Credential patterns to search for (default: password,token,key,auth,credential)

**Artefacts:**
- Process memory dump files in session directory (cleaned up automatically after execution)
- Detailed analysis log file with enumeration and search results (cleaned up automatically after execution)
- Session-specific dump directory with unique identifier (cleaned up automatically after execution)

**Detection opportunities:**
- Monitor dd command usage on /proc/<PID>/mem files
- Excessive /proc filesystem access patterns
- Memory mapping enumeration activities
- Process memory analysis and credential extraction attempts
- Creation of memory dump files in temporary directories

### T1110.002 - Hydra Brute Force Tool Simulation

**Description:**  
Simulates execution of the Hydra password brute-forcing tool by downloading a test file and executing it as 'hydra' to generate realistic attack tool telemetry.

**How it works:**
1. Downloads the Palo Alto Wildfire ELF test file (harmless malware test binary)
2. Saves the file with the name 'hydra' to simulate the password brute-force tool
3. Makes the file executable to trigger execution-based detections
4. Attempts to execute the binary (will fail safely but generates telemetry)
5. Logs all activities including download, file operations, and execution attempts

**Parameters:**
- `hydra_path`: Path where the simulated hydra binary will be saved (default: /tmp/hydra)
- `target_service`: Simulated target service type (ssh, ftp, http, etc.) (default: ssh)
- `log_file`: Path to save brute force attempt log (default: /tmp/signalbench_hydra_log)

**Artefacts:**
- Hydra binary file (Wildfire test file) (cleaned up automatically after execution)
- Brute force attempt log file (cleaned up automatically after execution)

**Detection opportunities:**
- Network connections to Wildfire test file URLs
- Download of files with known attack tool names
- Execution of processes named 'hydra' or other password brute-force tools
- File creation patterns matching attack tool installation
- chmod operations on files with suspicious names
- Repeated authentication attempts from single sources (if real hydra were used)

### T1003.008 - /etc/passwd and /etc/shadow

**Description:**  
Performs REAL extraction and analysis of /etc/passwd and /etc/shadow files to harvest user account information and password hashes. This supersized technique reads actual system files and attempts password hash cracking whilst remaining 100% safe and non-destructive.

**How it works:**
1. Reads REAL /etc/passwd file to enumerate all user accounts
2. Attempts to read /etc/shadow (requires root or sudo) to extract password hashes
3. Parses user account entries to extract:
   - Usernames
   - User IDs (UIDs)
   - Group IDs (GIDs)
   - Home directories
   - Login shells
   - GECOS fields (full names, contact info)
4. Identifies privileged accounts (UID 0, sudo group members)
5. Extracts password hashes from /etc/shadow for analysis:
   - SHA-512 hashes ($6$)
   - SHA-256 hashes ($5$)
   - MD5 hashes ($1$)
   - Blowfish hashes ($2a$, $2y$)
6. Simulates password cracking attempts using john or hashcat against extracted hashes
7. Creates comprehensive user enumeration reports
8. Identifies accounts with empty passwords or no passwords set
9. Maps users to their group memberships via /etc/group
10. Generates statistics on password hash algorithms and strengths

**Parameters:**
- `attempt_shadow_read`: Whether to attempt reading /etc/shadow (default: true)
- `crack_hashes`: Whether to simulate password cracking (default: true)
- `wordlist`: Path to wordlist for password cracking simulation (default: common passwords)
- `output_format`: Output format for results - text, json, csv (default: text)
- `enumerate_groups`: Whether to enumerate group memberships (default: true)

**Artefacts:**
- User enumeration report file (cleaned up automatically after execution)
- Extracted password hashes file (cleaned up automatically)
- Password cracking results (cleaned up automatically)
- Group membership mapping file (cleaned up automatically)

**Detection opportunities:**
- Monitor access to /etc/passwd and /etc/shadow files
- Detect reading of /etc/shadow by non-root processes
- Watch for grep/awk/sed commands parsing passwd/shadow files
- Monitor execution of password cracking tools (john, hashcat)
- Detect attempts to copy /etc/shadow to temporary directories
- File access patterns indicating user enumeration
- Unusual processes reading authentication-related files
- Sudo commands attempting to access /etc/shadow

## DEFENSE_EVASION Techniques

### T1027 - Obfuscated Files or Information

**Description:**  
Employs various obfuscation techniques to evade detection mechanisms and hide malicious content.

**How it works:**
1. Implements multiple obfuscation methods:
   - Base64 encoding/decoding
   - XOR encryption with custom keys
   - Text string manipulation and concatenation
   - Binary packing/compression
   - Script obfuscation techniques
2. Creates obfuscated files and demonstrates deobfuscation
3. Executes deobfuscated content to trigger detection
4. Logs all obfuscation operations for review

**Parameters:**
- `obfuscation_type`: Type of obfuscation to perform (encoding, encryption, packing, string)
- `output_dir`: Directory to save obfuscated files
- `log_file`: Path to save obfuscation log
- `execute_after`: Whether to attempt execution of obfuscated files

**Artefacts:**
- Obfuscated files (cleaned up automatically after execution)
- Deobfuscated files (cleaned up automatically)
- Obfuscation log file (cleaned up automatically)

**Detection opportunities:**
- Files containing encoded/obfuscated content
- Use of encoding/decoding functions
- Execution of decoded content
- Suspicious patterns in obfuscated files

### T1055 - Process Injection

**Description:**  
Injects code into running processes to evade detection and execute malicious code in the context of legitimate processes.

**How it works:**
1. Supports multiple injection techniques:
   - Ptrace-based code injection
   - LD_PRELOAD dynamic library loading
   - Shared library injection
2. Creates actual C code for injection
3. Compiles injection code on the target system
4. Performs real (but controlled) process injection
5. Logs all injection attempts and results

**Parameters:**
- `technique`: Specific injection technique (ptrace, ld_preload, shared_library)
- `target_process`: Target process name or PID (for ptrace)
- `output_dir`: Directory to save injection artefacts
- `log_file`: Path to save injection log

**Artefacts:**
- Injection source code files (cleaned up automatically)
- Compiled injection binaries (cleaned up automatically)
- Injected libraries (cleaned up automatically)
- Target process scripts (cleaned up automatically)
- Injection logs (cleaned up automatically)

**Detection opportunities:**
- Suspicious ptrace calls
- LD_PRELOAD manipulations
- Creation of shared libraries
- Process memory modifications
- Unusual process relationships

### T1562.002 - Disable Linux Audit Logs

**Description:**  
Simulates an attempt to disable or manipulate audit logs to avoid detection.

**How it works:**
1. Creates a file that simulates rules to disable Linux audit logging
2. Contains rules that would disable key system call auditing in a real attack
3. Does not actually modify system audit configuration

**Parameters:**
- `audit_rules_file`: Path to save the simulated audit rules

**Artefacts:**
- Audit rules file (cleaned up automatically after execution)

**Detection opportunities:**
- Modification of audit configuration files
- Commands that disable audit functionality

### T1070.003 - Clear Command History

**Description:**  
Simulates clearing of bash command history to remove evidence of attacker activity.

**How it works:**
1. Creates a backup of the current user's bash history
2. Simulates clearing the history by creating an empty file
3. Restores the original history during cleanup

**Parameters:**
- `history_backup`: Path to save the backup of bash history

**Artefacts:**
- History backup file (cleaned up automatically after execution)

**Detection opportunities:**
- Unusual modifications to history files
- Commands that clear or manipulate bash history

### T1574.007 - Path Interception

**Description:**  
Simulates path interception by modifying environment variables to control which binaries are executed.

**How it works:**
1. Documents current PATH and LD_LIBRARY_PATH variables
2. Simulates adding a malicious directory to the beginning of PATH
3. Creates a log file showing how a legitimate command could be intercepted

**Parameters:**
- `custom_path`: Directory to add to PATH variable
- `env_log_file`: Path to save the log file

**Artefacts:**
- Environment variable log file (cleaned up automatically after execution)

**Detection opportunities:**
- Unusual modifications to PATH or LD_LIBRARY_PATH
- Creation of executable files in non-standard locations

### T1036.003 - Masquerading

**Description:**  
Performs REAL process masquerading by copying system binaries and executing them with spoofed names to evade detection by mimicking legitimate system daemons. This supersized technique creates actual processes with misleading names and manipulated command-line arguments.

**How it works:**
1. Copies REAL system binaries (/bin/sh, /bin/bash) to temporary locations with legitimate daemon names (crond, systemd, sshd)
2. Sets executable permissions on masqueraded binaries
3. EXECUTES the masqueraded binaries to generate authentic process execution telemetry
4. Manipulates process names using exec -a for command-line spoofing
5. Creates multiple masquerading variants to test different detection scenarios
6. Generates realistic process trees with spoofed parent-child relationships
7. Logs all copying, execution, and process manipulation activities

**Parameters:**
- `daemon_names`: Comma-separated list of daemon names to masquerade as (default: crond,systemd,sshd)
- `target_dir`: Directory where masqueraded binaries will be created (default: /tmp)
- `execute_all`: Whether to execute all masqueraded binaries (default: true)
- `log_file`: Path to save masquerading log (default: /tmp/signalbench_masquerade_log)

**Artefacts:**
- Masqueraded binary files (cleaned up automatically after execution)
- Process execution logs with spoofed command lines (cleaned up automatically)
- Masquerading activity log file (cleaned up automatically)

**Detection opportunities:**
- Monitor for copying system binaries to uncommon locations
- Look for execve events with arguments like 'cp /bin/sh <path>/crond'
- Detect processes named 'crond', 'systemd', 'sshd' running from non-standard paths
- Watch for legitimate system daemon names in /tmp or other temporary directories
- Process name mismatches with expected execution paths and binary hashes
- Command-line manipulation patterns using exec -a

### T1070.004 - File Deletion

**Description:**  
Performs REAL secure file deletion using multiple overwriting techniques to simulate evidence destruction and anti-forensics activities. This supersized technique uses actual deletion tools (shred, wipe, srm) whilst maintaining 100% safety by only deleting test files.

**How it works:**
1. Creates test files with realistic sensitive content (credentials, logs, database dumps)
2. Implements REAL secure deletion using multiple methods:
   - shred -vfz -n 10 (10-pass overwrite with zeros)
   - wipe -rf (Gutmann 35-pass secure deletion)
   - srm -v (OpenBSD secure rm implementation)
   - dd if=/dev/urandom of=<file> bs=1M (random data overwriting)
3. Tests deletion permanence by attempting file recovery
4. Removes file system metadata using sync and directory cache clearing
5. Performs multi-pass overwrites with different patterns:
   - Random data (from /dev/urandom)
   - Zeros (0x00)
   - Ones (0xFF)
   - DOD 5220.22-M standard patterns
6. Verifies secure deletion by checking file inode status
7. Tests different file types: text logs, binary databases, archive files
8. Simulates timeline manipulation by touching files before deletion

**Parameters:**
- `deletion_method`: Secure deletion tool to use - shred, wipe, srm, dd (default: shred)
- `overwrite_passes`: Number of overwrite passes (default: 10)
- `test_file_count`: Number of test files to create and delete (default: 5)
- `file_sizes`: Comma-separated list of file sizes in MB (default: 1,5,10)
- `verify_deletion`: Whether to attempt file recovery verification (default: true)

**Artefacts:**
- Test files created for deletion testing (cleaned up through secure deletion)
- Deletion operation logs (cleaned up automatically after execution)
- Overwrite verification files (cleaned up automatically)

**Detection opportunities:**
- Monitor execution of secure deletion tools (shred, wipe, srm, secure-delete)
- Detect multiple write operations to same file (overwrite patterns)
- Watch for dd commands with /dev/urandom or /dev/zero as input
- Unusual file I/O patterns (repeated writes to same file location)
- Process behaviour indicating anti-forensics activities
- File deletion operations on sensitive file types (logs, databases, archives)
- Timeline manipulation attempts (touch, utimes system calls)

## EXECUTION Techniques

### T1059 - Advanced Command and Scripting Interpreter

**Description:**  
Executes malicious commands using various obfuscation techniques and scripting languages to test detection capabilities.

**How it works:**
1. Supports multiple interpreter types (bash, python, perl)
2. Implements various command obfuscation techniques:
   - Base64 encoding/decoding
   - Hex encoding/decoding
   - Variable concatenation
   - IFS (Internal Field Separator) manipulation
   - Command substitution
3. Creates and executes scripts with suspicious behaviours
4. Logs all command executions and their outputs

**Parameters:**
- `interpreter`: Type of interpreter to use (bash, python, perl)
- `obfuscation`: Obfuscation technique to apply (base64, hex, variable, none)
- `command`: Command to execute (if not specified, uses reconnaissance commands)
- `output_dir`: Directory to save execution artefacts
- `log_file`: Path to save execution logs

**Artefacts:**
- Temporary script files (cleaned up automatically after execution)
- Command output logs (cleaned up automatically)
- Execution history logs (cleaned up automatically)

**Detection opportunities:**
- Execution of encoded/obfuscated commands
- Use of suspicious command patterns
- Commands that access sensitive system information
- Use of eval or other execution functions in scripts
- Multiple command interpreter or encoding techniques in sequence

### T1059 - Possible C2 via dnscat2

**Description:**  
Downloads and executes a test file named dnscat2 to simulate command and control communications over DNS.

**How it works:**
1. Uses curl or wget to download a file from the Palo Alto Networks API
2. The downloaded file is a test file designed to look like dnscat2, a known C2 tool
3. The file is executed with basic C2 parameters to simulate a command and control session
4. This test intentionally triggers EDR/AV alerts as it uses a real-world C2 simulation file

**Parameters:**
- `download_url`: URL to download the file from (default uses a Palo Alto Networks test file)
- `output_file`: Path to save the downloaded file
- `log_file`: Path to save execution logs
- `c2_domain`: Domain to use for simulated C2 communications

**Artefacts:**
- Downloaded dnscat2 executable (cleaned up automatically after execution)
- C2 execution log file (cleaned up automatically after execution)

**Detection opportunities:**
- Download of known malicious or suspicious filenames
- Execution of tools known to be used for C2 communications
- DNS traffic patterns consistent with command and control channels
- Creation and execution of files with signatures matching known C2 tools

### T1059.004 - Unix Shell Execution

**Description:**  
Executes suspicious commands via Unix shell.

**How it works:**
1. Executes a specified command through a shell
2. Creates a log file documenting the command execution
3. Captures standard output and error from the command

**Parameters:**
- `shell`: Shell to use for command execution
- `command`: Command to execute
- `log_file`: Path to save execution log

**Artefacts:**
- Command execution log file (cleaned up automatically after execution)
- Any output file created by the executed command

**Detection opportunities:**
- Execution of unusual or suspicious shell commands
- Shell commands that create files in temporary directories

### T1059.006 - Python Script Execution

**Description:**  
Executes a potentially malicious Python script.

**How it works:**
1. Creates a Python script file with simulated malicious content
2. Script includes various suspicious behaviours like system reconnaissance, file operations
3. Executes the Python script and logs output

**Parameters:**
- `script_file`: Path to create and save the Python script
- `log_file`: Path to save execution log

**Artefacts:**
- Python script file (cleaned up automatically after execution)
- Script execution log file (cleaned up automatically after execution)
- Script output file (cleaned up automatically after execution)

**Detection opportunities:**
- Creation and execution of Python scripts with suspicious content
- Scripts that collect system information or simulate data exfiltration

### T1059.004.001 - Uncommon Remote Shell Commands

**Description:**  
Generates telemetry for uncommon command execution patterns with randomly generated suspicious command names to trigger baseline anomaly detection systems.

**How it works:**
1. Randomly generates command names with suspicious suffixes (backdoor, rootkit, keylogger, etc.)
2. Prefixes all commands with 'signalbench_' for safety and identification
3. Creates executable shell scripts with these uncommon command names
4. Executes each command to generate process execution telemetry
5. Logs all execution activities and outputs

**Parameters:**
- `command_count`: Number of uncommon commands to execute (default: 5)
- `log_file`: Path to save command execution log (default: /tmp/signalbench_uncommon_cmds)

**Artefacts:**
- Uncommon command scripts (e.g., /tmp/signalbench_backdoor, /tmp/signalbench_rootkit) (cleaned up automatically)
- Command execution log file (cleaned up automatically after execution)

**Detection opportunities:**
- Monitor for execution of never-before-seen commands (baseline anomaly detection)
- Detection of process names with malicious-sounding keywords
- Execution of binaries from temporary directories with suspicious names
- Process creation patterns matching known attack tool naming conventions
- File creation and immediate execution in /tmp directory
- Commands with prefixes like 'backdoor', 'rootkit', 'keylogger', 'cryptominer', 'ransomware'

## LATERAL_MOVEMENT Techniques

### T1021.004 - SSH Lateral Movement

**Description:**  
Simulates attempts to move laterally through a network using SSH.

**How it works:**
1. Attempts SSH connections to specified target hosts
2. Uses key-based authentication to avoid password prompts
3. Creates a log file documenting connection attempts and results

**Parameters:**
- `targets`: Comma-separated list of IPs or hostnames to target
- `username`: Username to use for SSH connections
- `log_file`: Path to save the log file

**Artefacts:**
- SSH connection log file (cleaned up automatically after execution)

**Detection opportunities:**
- Multiple SSH connection attempts in rapid succession
- SSH connections to unusual or varied destinations

## PERSISTENCE Techniques


### T1547.002 - Startup Folder

**Description:**  
Establishes REAL persistence by creating fully functional .desktop files in the user's XDG autostart directory that will execute commands automatically at user login. This supersized technique creates authentic persistence mechanisms that survive reboots.

**How it works:**
1. Creates the ~/.config/autostart directory if it doesn't exist
2. Generates a REAL .desktop file with proper XDG Desktop Entry specification format
3. Configures Type=Application with valid Exec, Name, and Comment fields
4. Sets the command to execute automatically when the user logs into their desktop environment
5. Supports both simple commands and complex shell scripts wrapped with /bin/sh -c
6. Creates multiple persistence entries with different application names for comprehensive testing
7. Validates .desktop file syntax to ensure it will be recognised by GNOME, KDE, XFCE environments
8. Tests autostart functionality by verifying file permissions and directory structure

**Parameters:**
- `app_name`: Name of the desktop application entry (default: SignalBench Persistence)
- `command`: Command to execute at startup (default: echo 'SignalBench startup executed' >> /tmp/signalbench_startup.log)
- `create_multiple`: Whether to create multiple autostart entries with different names (default: false)
- `hidden`: Whether to set Hidden=true to make entry invisible in autostart managers (default: false)

**Artefacts:**
- .desktop files in ~/.config/autostart directory (cleaned up automatically after execution)
- Autostart directory structure (cleaned up if created by technique)

**Detection opportunities:**
- Monitor .desktop file creation in ~/.config/autostart directory
- Desktop entry modifications with suspicious Exec commands
- XDG autostart persistence mechanisms in Linux desktop environments
- Hidden desktop entries (Hidden=true flag)
- Unusual application names in autostart directory
- Shell command wrappers in Exec fields (/bin/sh -c patterns)

### T1053.003 - Cron Job

**Description:**  
Creates REAL scheduled persistence by installing actual cron jobs that execute commands at specified intervals. This supersized technique modifies the user's live crontab to establish authentic time-based persistence mechanisms.

**How it works:**
1. Backs up the current user's crontab using crontab -l
2. Generates a new cron job entry with realistic scheduling (every 5 minutes, hourly, daily, etc.)
3. INSTALLS the modified crontab using crontab - to make changes live
4. Creates multiple cron job variants:
   - Frequent execution jobs (*/5 * * * * - every 5 minutes)
   - Stealthy daily jobs (0 3 * * * - 3 AM daily)
   - Boot-time jobs (@reboot)
5. Supports both simple commands and complex shell scripts
6. Validates cron syntax before installation
7. Tests job installation by querying crontab -l
8. Creates job output redirection to simulate covert execution (>/dev/null 2>&1)

**Parameters:**
- `cron_expression`: Cron expression for scheduling (default: */5 * * * *)
- `command`: Command to execute in cron job (default: /tmp/signalbench_persistence.sh)
- `create_multiple`: Whether to create multiple jobs with different schedules (default: false)
- `stealth_mode`: Whether to redirect output to /dev/null (default: true)

**Artefacts:**
- Modified user crontab (restored automatically during cleanup)
- Crontab backup file (cleaned up automatically after execution)
- Cron job entries (removed during cleanup via crontab restoration)

**Detection opportunities:**
- Monitor crontab command execution (crontab -, crontab -e)
- Modifications to user crontab files (/var/spool/cron/crontabs/*)
- Unusual or suspicious cron job entries with frequent execution intervals
- Commands redirecting output to /dev/null (stealth indicator)
- Cron jobs executing scripts from /tmp or other writable directories
- @reboot cron jobs for boot persistence

### T1543 - Create or Modify System Process

**Description:**  
Creates or modifies system services and processes to establish persistence on the system.

**How it works:**
1. Supports multiple service types:
   - systemd service units
   - init.d scripts
   - rc.local entries
2. Creates actual service definition files
3. Installs services (if permissions allow) or simulates installation
4. Attempts to start the service (controlled environment)
5. Logs all service creation operations

**Parameters:**
- `service_type`: Type of service to create (systemd, init.d, rc_local)
- `service_name`: Name for the service
- `command`: Command to execute when service runs
- `output_dir`: Directory to save service files
- `install`: Whether to attempt installation (requires privileges)

**Artefacts:**
- Service definition files (cleaned up automatically)
- Service installation logs (cleaned up automatically)
- Installed services (removed during cleanup if installed)

**Detection opportunities:**
- Creation of new service files
- Modifications to startup processes
- Services executing suspicious commands
- Services with unusual configurations or permissions

### T1505.003 - Web Shell Deployment

**Description:**  
Deploys REAL, functional web shells that can handle HTTP requests and execute commands on Linux-based web servers. This supersized technique creates authentic PHP, JSP, and Python backdoors with actual remote command execution capabilities for comprehensive testing.

**How it works:**
1. Creates web root directory structure (/tmp/www for safe testing)
2. Deploys REAL PHP web shells with $_GET, $_POST, and $_REQUEST handlers
3. Implements functional command execution using shell_exec(), system(), and passthru()
4. Creates JSP web shells with Runtime.getRuntime().exec() for Java environments
5. Builds Python Flask-based web shells for WSGI applications
6. Implements multiple web shell variants:
   - Simple one-liner shells (<?php system($_GET['cmd']); ?>)
   - Obfuscated shells with base64 encoding
   - Feature-rich shells with file upload, download, and directory browsing
7. Sets proper file permissions (644 or 755) to make shells executable by web server
8. Tests web shell functionality by invoking commands
9. Creates realistic file names (config.php, admin.php, upload.jsp) to evade detection

**Parameters:**
- `web_root`: Web server document root directory (default: /tmp/www)
- `shell_type`: Type of web shell to deploy - php, jsp, python (default: php)
- `shell_name`: Filename for the web shell (default: config.php)
- `create_multiple`: Whether to deploy multiple shell variants (default: true)
- `obfuscate`: Whether to use obfuscation techniques (default: false)

**Artefacts:**
- Web shell files (PHP, JSP, Python) (cleaned up automatically after execution)
- Web root directory structure (cleaned up automatically)
- Test command output files (cleaned up automatically)

**Detection opportunities:**
- Monitor web directories (/var/www, /usr/share/nginx, /tmp/www) for suspicious script files
- File creation in web document roots with common web shell names (shell.php, cmd.php, admin.jsp)
- PHP files containing dangerous functions (shell_exec, system, passthru, eval)
- JSP files with Runtime.getRuntime().exec() patterns
- Unusual web server child processes executing system commands
- Web application firewall (WAF) detection of command execution patterns
- File permission changes in web directories

### T1098 - Account Manipulation

**Description:**  
Performs REAL account manipulation by modifying user account properties, adding SSH keys, and changing group memberships to establish persistent access. This supersized technique makes actual changes to user accounts whilst maintaining 100% safety and reversibility.

**How it works:**
1. Creates test user accounts using useradd for manipulation testing
2. MODIFIES /etc/passwd entries to change user shells and home directories
3. Injects SSH public keys into authorized_keys files for key-based authentication
4. Adds users to privileged groups (sudo, wheel, adm) using usermod -aG
5. Modifies /etc/group directly to add users to multiple groups simultaneously
6. Changes user account attributes (comment field, UID, GID) for stealth
7. Creates .ssh directories with proper permissions (700 for directory, 600 for authorized_keys)
8. Tests SSH key injection by verifying authorized_keys file content
9. Backs up all modified files before changes for complete restoration
10. Implements multiple manipulation techniques:
    - Direct file editing (/etc/passwd, /etc/group, /etc/shadow)
    - System commands (usermod, gpasswd, chsh)
    - SSH configuration changes

**Parameters:**
- `target_user`: Username to manipulate (default: creates test user signalbench_test)
- `ssh_key_inject`: Whether to inject SSH public key (default: true)
- `add_to_groups`: Comma-separated list of groups to add user to (default: sudo,adm)
- `modify_shell`: New shell to set for user (default: /bin/bash)
- `backup_files`: Whether to backup files before modification (default: true)

**Artefacts:**
- Modified /etc/passwd entries (restored automatically during cleanup)
- Modified /etc/group entries (restored automatically)
- Injected SSH keys in ~/.ssh/authorized_keys (cleaned up automatically)
- Test user accounts created (removed automatically during cleanup)
- Backup files of modified system files (cleaned up automatically)

**Detection opportunities:**
- Monitor usermod, gpasswd, chsh command execution
- Watch for modifications to /etc/passwd, /etc/group, /etc/shadow files
- Detect SSH authorized_keys file modifications
- Monitor user additions to privileged groups (sudo, wheel, root)
- Track changes to user account attributes (UID, GID, shell, home directory)
- File integrity monitoring (FIM) alerts on critical system files
- Unusual .ssh directory creation in user home directories

## PRIVILEGE_ESCALATION Techniques

### T1548.003 - Sudoers Modification

**Description:**  
Simulates modifying the sudoers file to grant elevated privileges.

**How it works:**
1. Creates a temporary sudoers file in the /etc/sudoers.d/ directory
2. Grants specified privileges to a user
3. Validates syntax of the sudoers file before installation

**Parameters:**
- `username`: User to grant elevated privileges
- `privileges`: Privileges to grant (e.g., "ALL=(ALL:ALL) NOPASSWD: ALL")

**Artefacts:**
- Sudoers file in /etc/sudoers.d/ (cleaned up automatically after execution)

**Detection opportunities:**
- Creation or modification of files in /etc/sudoers.d/
- Changes to sudo privileges

### T1548.003.001 - Sudo Unsigned Integer Privilege Escalation

**Description:**  
Exploits CVE-2019-14287 sudo vulnerability using negative or large unsigned integer user IDs to bypass sudo restrictions and execute commands as root.

**How it works:**
1. Exploits a vulnerability in sudo versions < 1.8.28 where negative user IDs (-u#-1) or large unsigned integers (-u#4294967295) are interpreted as UID 0 (root)
2. Attempts to execute a specified command using both exploitation variants
3. Tests the vulnerability by running commands that would normally be restricted
4. Logs all exploitation attempts and results for analysis

**Parameters:**
- `command`: Command to execute via sudo exploitation (default: "id")
- `test_both_variants`: Whether to test both -u#-1 and -u#4294967295 methods (default: "true")
- `log_file`: Path to save exploitation log (default: "/tmp/signalbench_sudo_exploit.log")

**Artefacts:**
- Sudo exploitation log file (cleaned up automatically after execution)

**Detection opportunities:**
- Monitor for sudo commands with negative user IDs (-u#-1)
- Watch for sudo commands with large unsigned integers (-u#4294967295)
- Unusual sudo activity from non-privileged users attempting root access
- CVE-2019-14287 exploitation patterns in authentication logs

### T1548.001 - SUID Binary

**Description:**  
Simulates setting the SUID bit on a binary for privilege escalation.

**How it works:**
1. Creates a small executable file
2. Sets the SUID bit on the file
3. Simulates how this could be used for privilege escalation

**Parameters:**
- `target_binary`: Path to create the SUID binary

**Artefacts:**
- SUID binary file (cleaned up automatically after execution)

**Detection opportunities:**
- Creation of new SUID binaries
- Modification of file permissions to add SUID bit

### T1136.001 - Local Account Creation

**Description:**  
Adding new privileged users (e.g., via useradd, passwd, or direct /etc/passwd modification).

**How it works:**
1. Simulates creating new user accounts with elevated privileges
2. Creates harmless test files that represent user account entries
3. Does not modify actual system files for safety
4. Simulates /etc/passwd and /etc/shadow modifications

**Parameters:**
- `username`: Username for the new account
- `groups`: Groups to add the user to  
- `shell`: Default shell for the user

**Artefacts:**
- Test user account files (cleaned up automatically after execution)

**Detection opportunities:**
- Monitor for new user account creation
- Changes to /etc/passwd, /etc/shadow
- Unusual useradd/usermod commands

### T1068 - Exploitation for Privilege Escalation

**Description:**  
Using local privilege escalation exploits (e.g., Dirty Pipe, Dirty COW, kernel module exploits).

**How it works:**
1. Simulates common privilege escalation exploits
2. Creates realistic simulation logs based on exploit type
3. Detects kernel version for realistic testing
4. Completely harmless - only creates test files, no actual exploitation

**Parameters:**
- `exploit_type`: Type of privilege escalation exploit to simulate (dirty_pipe, dirty_cow, generic)
- `target_file`: Target file for the simulated exploit

**Artefacts:**
- Privilege escalation simulation files (cleaned up automatically after execution)

**Detection opportunities:**
- Monitor for unusual kernel module loading
- Suspicious process behaviour
- Exploitation indicators
- Privilege escalation attempts

## EXFILTRATION Techniques

### T1048 - Exfiltration Over Alternative Protocol

**Description:**  
Simulates data exfiltration using alternative protocols such as DNS, ICMP, or HTTP.

**How it works:**
1. Creates a file with simulated sensitive data for exfiltration
2. Encodes and formats data for the chosen protocol (base64 for DNS/HTTP, hex for ICMP)
3. Simulates the exfiltration process by showing the commands that would be executed
4. Creates detailed logs of the exfiltration process

**Parameters:**
- `protocol`: Protocol to use for exfiltration (dns, icmp, http)
- `data_file`: Path to save simulated data to be exfiltrated
- `log_file`: Path to save exfiltration log
- `target`: Target for exfiltration (domain for DNS, IP for ICMP, URL for HTTP)

**Artefacts:**
- Exfiltration data file (cleaned up automatically after execution)
- Exfiltration log file (cleaned up automatically after execution)

**Detection opportunities:**
- Unusual DNS queries with encoded data in subdomains
- ICMP packets with custom data payloads
- HTTP requests with encoded data in parameters
- High volume of network traffic using a single protocol

## COMMAND_AND_CONTROL Techniques

### T1095 - Non-Application Layer Protocol

**Description:**  
Executes actual command and control communications using non-application layer protocols (TCP, UDP, ICMP).

**How it works:**
1. Creates a file with C2 commands to be executed
2. Establishes actual communication channels using the chosen protocol
3. Transmits encoded commands and receives responses over the network
4. Uses netcat (nc) for TCP/UDP communications and ping for ICMP
5. Creates detailed logs of all C2 communication operations

**Parameters:**
- `protocol`: Protocol to use (icmp, tcp, udp)
- `target`: Target IP address
- `port`: Target port (for TCP/UDP)
- `log_file`: Path to save C2 simulation log
- `command_file`: Path to save C2 commands

**Artefacts:**
- C2 command file (cleaned up automatically after execution)
- C2 simulation log file (cleaned up automatically after execution)
- Temporary network socket files (cleaned up automatically)

**Detection opportunities:**
- Unusual protocol usage patterns
- Base64 or hex-encoded data in network traffic
- Regular beaconing or communication intervals
- Communication with unusual or suspicious external endpoints
- Use of netcat or similar networking tools

### T1205 - Traffic Signaling

**Description:**  
Uses cron to install TCP filters on network interfaces for covert signaling and command and control communications.

**How it works:**
1. Creates cron jobs to periodically install network traffic filters
2. Supports multiple filter types including iptables rules and tc (traffic control) filters
3. Configures filters to monitor specific TCP ports for incoming signals
4. Uses realistic cron scheduling to simulate persistent monitoring
5. Creates filter rules that could be used for covert C2 channel activation
6. Logs all cron job creation and filter installation activities

**Parameters:**
- `interface`: Network interface to install filter on (default: eth0)
- `filter_type`: Type of TCP filter - iptables or tc_filter (default: iptables)
- `target_port`: TCP port to filter for signaling (default: 8443)
- `cron_schedule`: Cron expression for filter installation (default: */15 * * * *)
- `log_file`: Path to save traffic signaling log (default: /tmp/signalbench_traffic_signaling.log)

**Artefacts:**
- Temporary cron job entries (cleaned up automatically after execution)
- Network filter rules and scripts (cleaned up automatically after execution)
- Traffic signaling log file (cleaned up automatically after execution)
- Filter installation scripts (cleaned up automatically after execution)

**Detection opportunities:**
- Monitor cron job modifications for network-related tasks
- Detect iptables or tc filter rule changes
- Monitor network interface configuration changes
- Unusual traffic patterns on filtered ports
- Periodic network filter installation activities
- Cron jobs executing network commands

### T1105 - Ingress Tool Transfer

**Description:**  
Downloads actual test files from external sources and attempts to execute them to test EDR/AV detection capabilities.

**How it works:**
1. Downloads files using curl or wget from specified URLs
2. Downloads include publicly available test files designed for security testing
3. Makes downloaded files executable and attempts to run them
4. Creates detailed logs of download operations and execution attempts
5. Default source is the Palo Alto Networks test file URL

**Parameters:**
- `url`: URL to download the malicious file from
- `output_dir`: Directory to save downloaded files
- `download_tool`: Tool to use for downloading (curl or wget)
- `execution_attempt`: Whether to attempt execution of downloaded files

**Artefacts:**
- Downloaded test files (cleaned up automatically after execution)
- Download and execution log file (cleaned up automatically)

**Detection opportunities:**
- File downloads from known security testing URLs
- Executable files being downloaded and made executable
- Attempt to execute recently downloaded files
- Suspicious file characteristics in downloaded content
### T1105.001 - Suspicious GitHub Tool Transfer

**Description:**  
Generates telemetry for curl requests to fictional GitHub repositories with hacker-themed names to trigger URL/domain-based anomaly detection systems.

**How it works:**
1. Randomly generates GitHub repository names with suspicious suffixes (exploit-kit, backdoor-tool, credential-dumper, etc.)
2. All repositories use the 'github.com/simonsigre/' prefix for consistency
3. Attempts curl requests to these fictional repositories (will return 404 but generates telemetry)
4. Creates realistic network request patterns that match tool download behaviour
5. Logs all download attempts and responses

**Parameters:**
- `repo_count`: Number of suspicious GitHub repos to attempt downloading from (default: 5)
- `log_file`: Path to save download attempt log (default: /tmp/signalbench_github_downloads.log)

**Artefacts:**
- GitHub download attempt log file (cleaned up automatically after execution)

**Detection opportunities:**
- Monitor for curl/wget requests to GitHub repositories with suspicious names
- Detection of URL patterns matching known attack tool repositories
- Network requests to rare or never-before-seen GitHub URLs
- Consecutive GitHub download attempts in short time periods
- URL/domain baseline anomaly detection for github.com/*/exploit-kit, github.com/*/backdoor-tool patterns
- Repository names containing keywords: exploit, backdoor, credential, ransomware, keylogger, botnet, webshell, rootkit, stealer, trojan
- HTTP 404 responses from GitHub repositories (fictional repos)

## COLLECTION Techniques

### T1119 - Automated Collection

**Description:**  
Performs REAL automated data collection by recursively enumerating and harvesting files from target directories. This supersized technique creates actual file archives containing collected data whilst maintaining 100% safety by only accessing non-sensitive test locations.

**How it works:**
1. Performs REAL recursive directory enumeration using find and ls -R
2. Searches for files matching collection criteria:
   - Document files (.pdf, .doc, .docx, .txt, .odt)
   - Spreadsheets (.xls, .xlsx, .csv, .ods)
   - Configuration files (.conf, .cfg, .ini, .yaml, .json)
   - Database files (.db, .sqlite, .sql)
   - Archive files (.zip, .tar, .gz, .7z)
   - Script files (.sh, .py, .rb, .pl)
3. Creates REAL compressed archives using tar and zip
4. Implements file staging in /tmp collection directory
5. Calculates file hashes (MD5, SHA256) for collected files
6. Generates collection manifests with file metadata:
   - File paths
   - File sizes
   - Modification timestamps
   - File permissions
   - Owner/group information
7. Performs content-based searches using grep for sensitive keywords
8. Tests multiple collection techniques:
   - Recursive find with -name patterns
   - grep -r for content matching
   - locate database searches
9. Simulates data staging for exfiltration preparation
10. Creates realistic collection statistics and reports

**Parameters:**
- `target_dirs`: Comma-separated list of directories to collect from (default: /tmp,/var/tmp)
- `file_patterns`: Comma-separated list of file extensions to collect (default: txt,pdf,doc,xls,csv)
- `create_archive`: Whether to create compressed archive of collected files (default: true)
- `archive_format`: Archive format to use - tar, zip, 7z (default: tar)
- `calculate_hashes`: Whether to calculate file hashes (default: true)
- `content_search`: Whether to search file contents for keywords (default: true)
- `search_keywords`: Comma-separated keywords to search for (default: password,secret,key,token)

**Artefacts:**
- Collection staging directory /tmp/signalbench_collection_<timestamp> (cleaned up automatically)
- Compressed archives of collected files (cleaned up automatically)
- Collection manifest files with metadata (cleaned up automatically)
- File hash databases (cleaned up automatically)
- Content search results (cleaned up automatically)

**Detection opportunities:**
- Monitor recursive directory enumeration (find, ls -R commands)
- Detect archive creation operations (tar, zip, 7z execution)
- Watch for file access patterns indicating systematic collection
- Monitor creation of staging directories in /tmp
- Detect file hash calculation operations
- Track grep -r operations searching for sensitive keywords
- Monitor file access to multiple document/database files in short time periods
- Unusual archive file creation with large file counts

## IMPACT Techniques

### T1496 - Resource Hijacking

**Description:**  
Performs REAL resource hijacking by consuming CPU, memory, and disk I/O to simulate cryptomining or resource exhaustion attacks. This supersized technique uses actual system stress tools whilst maintaining 100% safety through controlled execution and automatic cleanup.

**How it works:**
1. Implements REAL CPU consumption using stress-ng or custom CPU burners
2. Creates CPU-intensive operations:
   - Spawns multiple worker threads (one per CPU core)
   - Executes infinite loops with mathematical operations
   - Simulates cryptographic hashing (SHA-256, MD5)
3. Performs REAL memory consumption:
   - Allocates large memory blocks
   - Fills memory with data to trigger swapping
   - Creates memory pressure conditions
4. Executes REAL disk I/O saturation:
   - Writes large files to disk repeatedly
   - Performs random read/write operations
   - Stresses disk throughput with dd operations
5. Simulates cryptocurrency mining behaviour:
   - Creates processes named similar to miners (xmrig, ethminer, cpuminer)
   - Connects to mining pool addresses (simulated)
   - Generates realistic mining process telemetry
6. Implements resource monitoring:
   - Tracks CPU usage percentages
   - Monitors memory consumption
   - Measures disk I/O rates
7. Uses multiple stress tools:
   - stress-ng (comprehensive system stress)
   - cpulimit (CPU throttling)
   - Custom bash/python stress scripts
8. Creates realistic resource hijacking indicators:
   - High sustained CPU usage (80-100%)
   - Memory exhaustion patterns
   - Disk thrashing behaviour

**Parameters:**
- `stress_type`: Type of resource to stress - cpu, memory, disk, all (default: cpu)
- `cpu_workers`: Number of CPU worker threads (default: number of CPU cores)
- `duration`: Duration in seconds to run stress test (default: 30)
- `memory_size`: Amount of memory to consume in MB (default: 512)
- `disk_write_size`: Size of disk writes in MB (default: 100)
- `simulate_miner`: Whether to simulate cryptocurrency miner behaviour (default: true)
- `miner_name`: Name to use for simulated miner process (default: xmrig)

**Artefacts:**
- Stress test processes (terminated automatically after duration)
- Large temporary files for disk I/O testing (cleaned up automatically)
- Memory allocation buffers (freed automatically)
- Simulated miner processes (killed automatically)
- Resource consumption logs (cleaned up automatically)

**Detection opportunities:**
- Monitor sustained high CPU usage (>80% for extended periods)
- Detect process names matching known cryptocurrency miners
- Watch for unusual memory consumption patterns
- Monitor disk I/O saturation and thrashing
- Detect stress-ng, cpulimit, or similar tool execution
- Track processes consuming disproportionate system resources
- Monitor network connections to known mining pool addresses
- Detect mathematical operations indicative of mining (cryptographic hashing)
- Process tree analysis showing suspicious resource-intensive children

## SOFTWARE Simulations

The SOFTWARE category contains simulations of known malware families identified in the MITRE ATT&CK framework. These simulations use embedded helper binaries that match YARA signatures and behavioural patterns of real malware while remaining completely benign and safe to execute.

### S1109 - PACEMAKER

**EXPERIMENTAL: This implementation represents a research-grade simulation of PACEMAKER malware behaviour. Whilst the binary contains exact YARA signature matches and simulates documented credential-stealing techniques, there is no guarantee that endpoint detection and response (EDR) tools will generate alerts. This simulation has been developed to match Mandiant's technical documentation as closely as possible for security analytics research and training purposes.**

**Description:**  
Deploys a benign simulation of the PACEMAKER credential stealer that matches YARA signatures and behavioural patterns documented in the Mandiant April 2021 Pulse Secure APT investigation. This simulation contains an embedded 64-bit ELF binary with YARA signature strings and simulates the /proc filesystem credential scraping behaviour used by UNC2630 (suspected APT5) in attacks against U.S. Defense Industrial Base companies.

**Attribution:**  
PACEMAKER was used by threat group UNC2630 from August 2020 through March 2021 against U.S. Defense Industrial Base (DIB) companies. Mandiant assesses that UNC2630 operates on behalf of the Chinese government and may have ties to APT5. The malware was part of a sophisticated toolkit alongside SLOWPULSE, RADIALPULSE, THINBLOOD, and ATRIUM used to compromise Pulse Secure VPN appliances and harvest credentials for lateral movement into victim networks.

**Background:**  
PACEMAKER is a credential-stealing malware documented in Mandiant's April 19, 2021 report "Check Your Pulse: Suspected APT Actors Leverage Authentication Bypass Techniques and Pulse Secure Zero-Day". The malware reads process memory via the /proc filesystem to extract authentication credentials from Pulse Secure VPN daemon processes. It writes harvested credentials to files in /tmp with `.statementcounters` extensions to blend in with legitimate Pulse Secure system files, making detection more difficult.

The malware specifically targets authentication realms used by Pulse Secure VPN including LDAP, RADIUS, and ACE authentication systems, extracting usernames, passwords, and authentication tokens from process memory.

**How it works:**
1. Extracts an embedded 64-bit ELF binary to /tmp/signalbench_sim-pacemaker
2. The binary contains YARA signature strings matching FE_APT_Trojan_Linux_PACEMAKER rules:
   - `/proc/%d/mem` - Used to read process memory for credential extraction
   - `/proc/%s/maps` - Used to locate credential data in memory regions
   - `/proc/%s/cmdline` - Used to identify target Pulse Secure daemon processes
   - `Name:%s || Pwd:%s || AuthNum:%s` - Credential format string for harvested data
3. Creates a launcher script based on the documented PACEMAKER launcher (SHA256: 4c5555955b2e6dc55f52b0c1a3326f3d07b325b112060329c503b294208960ec). Note: The generated script uses different paths (/tmp/signalbench_sim-pacemaker instead of /home/bin/memread) and includes comments, so it will not produce an exact SHA256 match to the original. The functional behaviour remains identical.
4. Simulates realistic /proc filesystem inspection behaviour:
   - Reads /proc/self/maps to simulate memory region scanning
   - Reads /proc/self/cmdline to simulate process identification
   - Attempts to access /proc/self/mem to simulate credential extraction
5. Executes the simulation with parameters: `-t <timeout> -m 16 -s 2` (mimicking memread utility)
6. Creates three credential harvesting files matching Mandiant documentation:
   - /tmp/signalbench_sim_dsactiveuser.statementcounters
   - /tmp/signalbench_sim_dsstartssh.statementcounters
   - /tmp/signalbench_sim_dsserver-check.statementcounters

**Parameters:**
- `timeout`: Timeout in seconds for memread simulation (default: 3)
- `memory_size`: Memory read size in MB (default: 16)
- `scan_interval`: Memory scan interval in seconds (default: 2)

**Artefacts:**
- /tmp/signalbench_sim-pacemaker (ELF binary with YARA signatures, cleaned up automatically)
- /tmp/signalbench_sim-pacemaker-launcher.sh (bash launcher script, cleaned up automatically)
- /tmp/signalbench_sim_dsactiveuser.statementcounters (credential file, cleaned up automatically)
- /tmp/signalbench_sim_dsstartssh.statementcounters (credential file, cleaned up automatically)
- /tmp/signalbench_sim_dsserver-check.statementcounters (credential file, cleaned up automatically)

**YARA Detection:**
This simulation is designed to trigger YARA rules from the Mandiant/FireEye PulseSecure APT report:
- `FE_APT_Trojan_Linux_PACEMAKER`: Detects ELF binaries with proc filesystem strings and credential format
- `FE_APT_Trojan_Linux32_PACEMAKER`: Detects 32-bit ELF binaries with specific x86 byte patterns

To test YARA detection:
```bash
# Run simulation with artifacts preserved
signalbench run S1109 --no-cleanup

# Scan with YARA rules
yara -s pacemaker_rules.yar /tmp/signalbench_sim-pacemaker
```

**Detection opportunities:**
- YARA signature detection (FE_APT_Trojan_Linux_PACEMAKER rules)
- File creation patterns in /tmp/ds*.statementcounters
- Execution of binaries from /tmp directory
- Process memory access patterns (/proc/*/mem, /proc/*/maps access)
- Suspicious process names or command-line arguments
- File naming patterns matching known APT artifacts
- Behavioural analysis of credential harvesting activities

**References:**
- Mandiant Report: "Suspected APT Actors Leverage Bypass Techniques, Pulse Secure Zero-Day"
- MITRE ATT&CK Software: https://attack.mitre.org/software/S1109/
